using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using TestCoverage.Rewrite;

namespace TestCoverage.Compilation
{
    public class RoslynCompiler : ICompiler
    {
        public ICompiledItem[] Compile(IEnumerable<CompilationItem> allItems)
        {
            var allItemsArray = allItems.ToArray();

            var compiledItems = new List<RoslynCompiledItem>();

            foreach (var compilationItem in allItemsArray)
            {
                Compile(compilationItem, allItemsArray, compiledItems, GetAuditDllReference());
            }

            foreach (var compiledItem in compiledItems)
                compiledItem.EmitAndSave();

            return compiledItems.ToArray();
        }

        public ICompiledItem[] Compile(CompilationItem item, IEnumerable<string> references)
        {
            var compiledItems = new List<RoslynCompiledItem>();

            var requiredReferences =
                item.Project.MetadataReferences.Union(
                    references.Select(r => MetadataReference.CreateFromFile(r))).ToList();
            requiredReferences.Add(GetAuditDllReference());

            string newDllName = PathHelper.GetCoverageDllName(item.Project.Name);
            CSharpCompilation compiledDll = Compile(newDllName, item.SyntaxTrees, requiredReferences.ToArray());

            compiledItems.Add(new RoslynCompiledItem(item.Project, compiledDll));

            foreach (var compiledItem in compiledItems)
                compiledItem.EmitAndSave();

            return compiledItems.ToArray();
        }

        private MetadataReference GetAuditDllReference()
        {
            return MetadataReference.CreateFromFile(typeof (AuditVariablesAutoGenerated941C).Assembly.Location);
        }
        private void Compile(CompilationItem item, IEnumerable<CompilationItem> allItems, List<RoslynCompiledItem> currentlyCompiledItems, MetadataReference auditReference)
        {
            if (currentlyCompiledItems.Any(c => c.Project == item.Project))
                return;

            foreach (ProjectReference projectReference in item.Project.ProjectReferences)
            {
                CompilationItem referencedItem = allItems.Single(i => i.Project.Id == projectReference.ProjectId);
                Compile(referencedItem, allItems, currentlyCompiledItems, auditReference);
            }

            MetadataReference[] projectReferences = GetProjectReferences(item.Project, currentlyCompiledItems);
            MetadataReference[] auditReferences = { auditReference };
            MetadataReference[] requiredReferences = projectReferences.Union(item.Project.MetadataReferences).Union(auditReferences).ToArray();

            string newDllName = PathHelper.GetCoverageDllName(item.Project.Name);
            CSharpCompilation compilation = Compile(newDllName, item.SyntaxTrees, requiredReferences);

            currentlyCompiledItems.Add(new RoslynCompiledItem(item.Project, compilation));
        }

        private MetadataReference[] GetProjectReferences(Project project, List<RoslynCompiledItem> compiledItems)
        {
            var metadataReferences = new List<MetadataReference>();

            foreach (ProjectReference projectReference in project.AllProjectReferences)
            {
                RoslynCompiledItem roslynCompiledItem = compiledItems.Single(i => i.Project.Id == projectReference.ProjectId);

                metadataReferences.Add(roslynCompiledItem.Compilation.ToMetadataReference());
            }

            return metadataReferences.ToArray();
        }

        private static CSharpCompilation Compile(string dllName, SyntaxTree[] allTrees, MetadataReference[] references)
        {
            var settings = new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary).
                WithAssemblyIdentityComparer(DesktopAssemblyIdentityComparer.Default)
                .WithOptimizationLevel(OptimizationLevel.Release);

            CSharpCompilation compilation = CSharpCompilation.Create(
                dllName,
                allTrees,
                references,
                settings);

            return compilation;
        }
    }
}
